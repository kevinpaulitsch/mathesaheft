<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>SV Tillmitsch – Textaufgaben-Trainer</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 80px 24px 24px 24px; /* oben Platz fürs Menü */
    max-width: 1000px;
    background: #111;
    color: #eee;
  }

  /* Top-Menü (gleich wie auf index.html) */
  .top-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #000;
    border-bottom: 2px solid #d4af37;
    z-index: 1000;
  }
  .top-nav-inner {
    max-width: 1000px;
    margin: 0 auto;
    padding: 8px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .top-nav-title {
    font-weight: bold;
    color: #d4af37;
    margin-right: 16px;
  }
  .top-nav-link {
    color: #fff;
    text-decoration: none;
    font-size: 0.95em;
    padding: 4px 8px;
    border-radius: 4px;
  }
  .top-nav-link:hover {
    background: #222;
  }
  .top-nav-link.active {
    background: #d4af37;
    color: #000;
  }

  h1 {
    text-align: center;
    color: #d4af37;
    text-shadow: 1px 1px #000;
    margin-bottom: 5px;
  }

  img.logo {
    width: 180px;
    display: block;
    margin: 10px auto 20px auto;
  }

  .info-text {
    font-size: 0.95em;
    color: #ddd;
    margin-bottom: 10px;
  }

  .level-bar {
    margin: 12px 0 12px 0;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #1b1b1b;
  }
  select {
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid #d4af37;
    background: #000;
    color: #eee;
  }
  .difficulty-note {
    font-size: 0.8em;
    color: #ccc;
    margin-top: 4px;
  }

  /* Meta-Bar (XP, Level, Streaks) */
  .meta-bar {
    margin: 6px 0 18px 0;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #181818;
    font-size: 0.9em;
  }
  .meta-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
  }
  .meta-row-small {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 6px;
  }
  .xp-bar {
    flex: 1;
    height: 10px;
    background: #333;
    border-radius: 5px;
    overflow: hidden;
  }
  .xp-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #ff7f00, #d4af37);
    transition: width 0.3s;
  }
  #levelLabel {
    font-weight: bold;
    color: #d4af37;
  }
  #xpLabel, #todayXpLabel, #streakLabel, #dayStreakLabel {
    font-size: 0.85em;
    color: #ccc;
  }

  /* Achievements */
  .achievements-panel {
    display: none;
    margin-bottom: 16px;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #181818;
    font-size: 0.9em;
  }
  .achievement-item {
    margin-bottom: 4px;
  }
  .badge {
    display: inline-block;
    min-width: 14px;
    text-align: center;
    border-radius: 50%;
    padding: 0 4px;
    margin-right: 4px;
    font-weight: bold;
  }
  .badge-ok {
    background: #3a3;
    color: #000;
  }
  .badge-miss {
    background: #555;
    color: #aaa;
  }

  .section-box {
    margin-top: 20px;
  }

  .section-progress {
    font-size: 0.9em;
    color: #9f9;
    margin-bottom: 8px;
  }

  .card {
    border: 2px solid #d4af37;
    border-radius: 6px;
    margin: 10px 0;
    background: #1b1b1b;
  }
  .card-header {
    padding: 8px 10px;
    font-weight: bold;
    font-size: 0.95em;
  }
  .card-body {
    padding: 8px 10px;
    border-top: 1px solid #444;
  }
  textarea {
    width: 100%;
    min-height: 40px;
    margin-top: 6px;
    border: 1px solid #d4af37;
    padding: 4px;
    background: #000;
    color: #eee;
  }
  .solution {
    display: none;
    margin-top: 6px;
    padding: 8px;
    border-left: 4px solid #ff7f00;
    background: #333;
  }
  .feedback {
    margin-top: 4px;
    font-size: 0.9em;
  }
  .feedback.ok {
    color: #9f9;
  }
  .feedback.bad {
    color: #f99;
  }
  button {
    background: #ff7f00;
    color: #000;
    padding: 6px 12px;
    border: none;
    margin-top: 8px;
    margin-right: 6px;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
  }
  button:active {
    transform: scale(0.97);
  }
</style>
</head>
<body>

<!-- Gemeinsames Menü -->
<div class="top-nav">
  <div class="top-nav-inner">
    <span class="top-nav-title">SV Tillmitsch</span>
    <a class="top-nav-link" href="index.html">Mathe-Trainer</a>
    <a class="top-nav-link active" href="textaufgaben.html">Textaufgaben</a>
    <a class="top-nav-link" href="sa-generator.html">Schularbeit</a>
  </div>
</div>

<h1>Textaufgaben-Trainer</h1>
<img src="logo.png" alt="SV Tillmitsch Logo" class="logo">

<p class="info-text">
Für 1. Klasse Gymnasium. Es werden pro Durchgang <b>20 zufällige Textaufgaben</b> erstellt.
Du löst jede Aufgabe direkt am Gerät, lässt sie automatisch prüfen und sammelst XP.
Die XP zählen gemeinsam mit dem normalen Trainer (Level & Freischaltung der Stufen).
</p>

<div class="level-bar">
  <strong>Schwierigkeitsgrad:</strong>
  <select id="difficultySelect">
    <option value="easy">Leicht</option>
    <option value="medium">Mittel</option>
    <option value="hard">Schwer</option>
  </select>
  <div class="difficulty-note">
    Mittel ab Level 3, Schwer ab Level 6 freigeschaltet (gemeinsam mit dem Haupttrainer).
  </div>
</div>

<!-- XP / Level / Streaks -->
<div id="metaBar" class="meta-bar">
  <div class="meta-row">
    <span id="levelLabel">Level 1</span>
    <div class="xp-bar">
      <div id="xpFill" class="xp-fill"></div>
    </div>
    <span id="xpLabel">0 / 200 XP</span>
  </div>
  <div class="meta-row-small">
    <span id="todayXpLabel">Heute: 0 / 150 XP</span>
    <span id="streakLabel">Aufgaben-Serie: 0 (Best: 0)</span>
    <span id="dayStreakLabel">Tages-Streak: 0 Tage</span>
  </div>
  <button id="toggleAchievementsBtn" type="button">Erfolge anzeigen</button>
</div>

<div id="achievementsPanel" class="achievements-panel">
  <strong>Erfolge:</strong>
  <div id="achievementsList"></div>
</div>

<div class="section-box">
  <h2>Textaufgaben – gemischte Übungen</h2>
  <div class="section-progress" id="progress-text">
    Heutiger Durchgang: 0 / 0 von 0 Aufgaben | Gesamt: noch keine Daten
  </div>
  <button id="newTasksBtn" type="button">Neue Textaufgaben erzeugen</button>
  <div id="tasksContainer"></div>
</div>

<script>
  const TASKS_PER_ROUND = 20;
  const SECTION_KEY = "TEXT";

  // Session-Progress
  let progress = { total: 0, answered: 0, correct: 0 };

  // Langzeit-Statistik
  let statsStore = {}; // {sectionKey: {totalAnswered, totalCorrect}}

  // Meta (XP, Level, Streaks, Achievements, Speed-Bestwerte)
  let meta = {
    xp: 0,
    totalCorrect: 0,
    totalAnswered: 0,
    currentStreak: 0,
    bestStreak: 0,
    lastDayISO: null,
    dayStreak: 0,
    todayXp: 0,
    achievements: {}, // {id: true}
    bestSpeed: {}      // {sectionKey: {correct, total}}
  };

  let currentDifficulty = "easy";

  const ACHIEVEMENTS = [
    {
      id: "starter",
      label: "Starter",
      desc: "10 Aufgaben richtig.",
      check: m => m.totalCorrect >= 10
    },
    {
      id: "hundert",
      label: "Rechenkönig",
      desc: "100 Aufgaben richtig.",
      check: m => m.totalCorrect >= 100
    },
    {
      id: "roundingPro",
      label: "Runden-Profi",
      desc: "Mindestens 30 richtige Runden/Text-Aufgaben.",
      check: () => {
        const s = statsStore["TEXT"];
        return s && s.totalCorrect >= 30;
      }
    },
    {
      id: "streak10",
      label: "Serie 10",
      desc: "10 Aufgaben in Folge richtig.",
      check: m => m.bestStreak >= 10
    },
    {
      id: "streak20",
      label: "Serie 20",
      desc: "20 Aufgaben in Folge richtig.",
      check: m => m.bestStreak >= 20
    },
    {
      id: "day7",
      label: "7-Tage-Streak",
      desc: "7 Tage in Folge gelernt.",
      check: m => m.dayStreak >= 7
    },
    {
      id: "speed10",
      label: "Speed-Runner",
      desc: "In einer Speed-Challenge mindestens 10 richtige Aufgaben (auf dem Haupttrainer).",
      check: m => {
        if (!m.bestSpeed) return false;
        return Object.values(m.bestSpeed).some(b => b.correct >= 10);
      }
    }
  ];

  // ---- localStorage laden (gemeinsam mit index.html) ----
  try {
    const stored = localStorage.getItem("trainerStats");
    if (stored) statsStore = JSON.parse(stored) || {};
  } catch(e) { statsStore = {}; }

  try {
    const m = localStorage.getItem("trainerMeta");
    if (m) {
      const parsed = JSON.parse(m);
      if (parsed && typeof parsed === "object") {
        meta = Object.assign(meta, parsed);
      }
    }
  } catch(e) { /* ignore */ }

  try {
    const d = localStorage.getItem("trainerDifficulty");
    if (d && (d === "easy" || d === "medium" || d === "hard")) {
      currentDifficulty = d;
    }
  } catch(e) { currentDifficulty = "easy"; }

  function saveStatsStore() {
    localStorage.setItem("trainerStats", JSON.stringify(statsStore));
  }
  function saveMeta() {
    localStorage.setItem("trainerMeta", JSON.stringify(meta));
  }
  function saveDifficulty() {
    localStorage.setItem("trainerDifficulty", currentDifficulty);
  }

  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

  function getNumericAnswer(ans) {
    if (typeof ans === "number") return ans;
    if (typeof ans !== "string") return null;
    const trimmed = ans.trim().replace(",", ".");
    if (/^-?\d+(\.\d+)?$/.test(trimmed)) return parseFloat(trimmed);
    return null;
  }

  // Level & XP
  function computeLevel() {
    const xpPerLevel = 200;
    const level = Math.floor(meta.xp / xpPerLevel) + 1;
    const xpInto = meta.xp % xpPerLevel;
    const xpNeeded = xpPerLevel;
    return { level, xpInto, xpNeeded };
  }

  function updateDifficultyLock(level) {
    const select = document.getElementById("difficultySelect");
    if (!select) return;

    const optEasy = select.querySelector('option[value="easy"]');
    const optMedium = select.querySelector('option[value="medium"]');
    const optHard = select.querySelector('option[value="hard"]');

    const mediumUnlocked = level >= 3;
    const hardUnlocked = level >= 6;

    if (optEasy) optEasy.disabled = false;
    if (optMedium) optMedium.disabled = !mediumUnlocked;
    if (optHard) optHard.disabled = !hardUnlocked;

    if (currentDifficulty === "hard" && !hardUnlocked) {
      currentDifficulty = mediumUnlocked ? "medium" : "easy";
    }
    if (currentDifficulty === "medium" && !mediumUnlocked) {
      currentDifficulty = "easy";
    }

    select.value = currentDifficulty;
    saveDifficulty();
  }

  function updateAchievementsUI() {
    const panel = document.getElementById("achievementsPanel");
    const list = document.getElementById("achievementsList");
    if (!panel || !list) return;

    list.innerHTML = "";
    ACHIEVEMENTS.forEach(def => {
      const done = !!meta.achievements[def.id];
      const el = document.createElement("div");
      el.className = "achievement-item";

      const badge = document.createElement("span");
      badge.className = "badge " + (done ? "badge-ok" : "badge-miss");
      badge.textContent = done ? "✔" : "✖";
      el.appendChild(badge);

      const text = document.createElement("span");
      text.innerHTML = "<strong>" + def.label + ":</strong> " + def.desc;
      el.appendChild(text);

      list.appendChild(el);
    });
  }

  function updateMetaUI() {
    const { level, xpInto, xpNeeded } = computeLevel();
    const levelLabel = document.getElementById("levelLabel");
    const xpLabel = document.getElementById("xpLabel");
    const xpFill = document.getElementById("xpFill");
    const todayXpLabel = document.getElementById("todayXpLabel");
    const streakLabel = document.getElementById("streakLabel");
    const dayStreakLabel = document.getElementById("dayStreakLabel");

    if (levelLabel) levelLabel.textContent = "Level " + level;
    if (xpLabel) xpLabel.textContent = xpInto + " / " + xpNeeded + " XP";
    if (xpFill) xpFill.style.width = (xpNeeded > 0 ? (xpInto / xpNeeded * 100).toFixed(1) : 0) + "%";

    const dailyTarget = 150;
    if (todayXpLabel) {
      todayXpLabel.textContent = "Heute: " + meta.todayXp + " / " + dailyTarget + " XP";
    }
    if (streakLabel) {
      streakLabel.textContent = "Aufgaben-Serie: " + meta.currentStreak + " (Best: " + meta.bestStreak + ")";
    }
    if (dayStreakLabel) {
      dayStreakLabel.textContent = "Tages-Streak: " + meta.dayStreak + " Tage";
    }

    updateDifficultyLock(level);
    updateAchievementsUI();
  }

  function addXp(amount) {
    if (amount <= 0) return;
    const now = new Date();
    const todayISO = now.toISOString().slice(0,10);

    if (meta.lastDayISO !== todayISO) {
      if (meta.lastDayISO) {
        const last = new Date(meta.lastDayISO);
        const diffDays = Math.round((now - last) / (1000*60*60*24));
        if (diffDays === 1) {
          meta.dayStreak = (meta.dayStreak || 0) + 1;
        } else {
          meta.dayStreak = 1;
        }
      } else {
        meta.dayStreak = 1;
      }
      meta.todayXp = 0;
      meta.lastDayISO = todayISO;
    }

    meta.xp += amount;
    meta.todayXp += amount;
    saveMeta();
  }

  function checkAchievements() {
    let unlockedSomething = false;
    ACHIEVEMENTS.forEach(def => {
      if (meta.achievements[def.id]) return;
      let ok = false;
      try {
        ok = !!def.check(meta);
      } catch(e) { ok = false; }
      if (ok) {
        meta.achievements[def.id] = true;
        unlockedSomething = true;
      }
    });
    if (unlockedSomething) {
      saveMeta();
      updateMetaUI();
    }
  }

  function onCorrectAnswer() {
    meta.totalCorrect++;
    meta.currentStreak++;
    if (meta.currentStreak > meta.bestStreak) {
      meta.bestStreak = meta.currentStreak;
    }
    addXp(10);
    saveMeta();
    checkAchievements();
    updateMetaUI();
  }

  function updateProgressDisplay() {
    const el = document.getElementById("progress-text");
    if (!el) return;

    const sessionStr = "Heutiger Durchgang: " +
      progress.correct + " / " + progress.answered +
      " von " + progress.total + " Aufgaben";

    const global = statsStore[SECTION_KEY] || {totalAnswered:0, totalCorrect:0};
    let globalStr = "Gesamt: noch keine Daten";
    if (global.totalAnswered > 0) {
      const pct = Math.round((global.totalCorrect / global.totalAnswered) * 100);
      globalStr = "Gesamt: " + global.totalCorrect + " / " +
        global.totalAnswered + " (" + pct + "%)";
    }

    el.textContent = sessionStr + " | " + globalStr;
  }

  // --- Textaufgaben-Generator ---
  // Jede Aufgabe: { q: "Text...", a: Zahl }

  function generateTextTask(diff) {
    const type = randInt(1, 6);

    if (type === 1) {
      // Einkaufen: Summen
      let minPrice, maxPrice, items;
      if (diff === "easy") {
        minPrice = 1; maxPrice = 9; items = 2;
      } else if (diff === "medium") {
        minPrice = 2; maxPrice = 15; items = 3;
      } else {
        minPrice = 5; maxPrice = 25; items = 4;
      }
      const prices = [];
      for (let i = 0; i < items; i++) {
        prices.push(randInt(minPrice, maxPrice));
      }
      const total = prices.reduce((s,v)=>s+v,0);
      const text = `Beim Einkaufen kostet ein Artikel ${prices[0]} €` +
                   `${items>1?(", ein zweiter "+prices[1]+" €"): ""}` +
                   `${items>2?(", ein dritter "+prices[2]+" €"): ""}` +
                   `${items>3?(", ein vierter "+prices[3]+" €"): ""}.` +
                   ` Wie viel Euro muss man insgesamt bezahlen?`;
      return { q: text, a: total };
    }

    if (type === 2) {
      // Fußball – Tore zählen
      let spiele, toreMin, toreMax;
      if (diff === "easy") {
        spiele = 2; toreMin = 0; toreMax = 4;
      } else if (diff === "medium") {
        spiele = 3; toreMin = 0; toreMax = 5;
      } else {
        spiele = 4; toreMin = 0; toreMax = 6;
      }
      const tore = [];
      for (let i = 0; i < spiele; i++) {
        tore.push(randInt(toreMin, toreMax));
      }
      const sum = tore.reduce((s,v)=>s+v,0);
      const text = `Eine Mannschaft spielt ${spiele} Spiele. Im 1. Spiel schießt sie ${tore[0]} Tore` +
                   `${spiele>1?(", im 2. Spiel "+tore[1]+" Tore"): ""}` +
                   `${spiele>2?(", im 3. Spiel "+tore[2]+" Tore"): ""}` +
                   `${spiele>3?(", im 4. Spiel "+tore[3]+" Tore"): ""}.` +
                   ` Wie viele Tore schießt die Mannschaft insgesamt?`;
      return { q: text, a: sum };
    }

    if (type === 3) {
      // Gruppenbildung
      let kinder, proGruppe;
      if (diff === "easy") {
        proGruppe = randInt(3,5);
        kinder = proGruppe * randInt(2,4);
      } else if (diff === "medium") {
        proGruppe = randInt(4,6);
        kinder = proGruppe * randInt(3,5);
      } else {
        proGruppe = randInt(5,8);
        kinder = proGruppe * randInt(4,7);
      }
      const gruppen = Math.floor(kinder / proGruppe);
      const text = `In einer Halle sind ${kinder} Kinder. Es sollen gleich große Gruppen mit jeweils ${proGruppe} Kindern gebildet werden.` +
                   ` Wie viele Gruppen entstehen?`;
      return { q: text, a: gruppen };
    }

    if (type === 4) {
      // Vielfaches – Kartons
      let proKarton, kartons;
      if (diff === "easy") {
        proKarton = randInt(3,6);
        kartons = randInt(2,4);
      } else if (diff === "medium") {
        proKarton = randInt(4,10);
        kartons = randInt(3,6);
      } else {
        proKarton = randInt(6,15);
        kartons = randInt(4,8);
      }
      const gesamt = proKarton * kartons;
      const text = `Ein Karton enthält ${proKarton} Flaschen. Es werden ${kartons} Kartons geliefert.` +
                   ` Wie viele Flaschen sind das insgesamt?`;
      return { q: text, a: gesamt };
    }

    if (type === 5) {
      // Runden im Alltag
      let zahl;
      let stelleText;
      if (diff === "easy") {
        zahl = randInt(100,999);
        stelleText = "Zehner";
        const gerundet = Math.round(zahl/10)*10;
        const text = `Ein Auto kostet ungefähr ${zahl} €. Runde den Preis auf den nächsten ${stelleText}.`;
        return { q: text, a: gerundet };
      } else if (diff === "medium") {
        zahl = randInt(1000,9999);
        stelleText = "Hunderter";
        const gerundet = Math.round(zahl/100)*100;
        const text = `Eine Schule plant eine Anschaffung und schätzt die Kosten auf ${zahl} €. Runde auf den nächsten ${stelleText}.`;
        return { q: text, a: gerundet };
      } else {
        zahl = randInt(5000,99999);
        stelleText = "Tausender";
        const gerundet = Math.round(zahl/1000)*1000;
        const text = `Eine Gemeinde schätzt die Ausgaben für ein Projekt auf ${zahl} €. Runde den Betrag auf den nächsten ${stelleText}.`;
        return { q: text, a: gerundet };
      }
    }

    // type === 6: Gewinn/Verlust
    let start, plus, minus;
    if (diff === "easy") {
      start = randInt(10,50);
      plus = randInt(5,20);
      minus = randInt(1,10);
    } else if (diff === "medium") {
      start = randInt(40,120);
      plus = randInt(10,40);
      minus = randInt(5,25);
    } else {
      start = randInt(80,200);
      plus = randInt(20,70);
      minus = randInt(10,50);
    }
    const end = start + plus - minus;
    const text = `Am Anfang hat jemand ${start} €. Danach bekommt die Person ${plus} € dazu und gibt später ${minus} € aus.` +
                 ` Wie viel Geld besitzt sie am Ende?`;
    return { q: text, a: end };
  }

  function generateRound() {
    const tasksContainer = document.getElementById("tasksContainer");
    tasksContainer.innerHTML = "";

    progress = { total: TASKS_PER_ROUND, answered: 0, correct: 0 };
    updateProgressDisplay();

    for (let i = 0; i < TASKS_PER_ROUND; i++) {
      const t = generateTextTask(currentDifficulty);
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.answered = "false";
      card.dataset.wasCorrect = "false";

      const head = document.createElement("div");
      head.className = "card-header";
      head.textContent = "Aufgabe " + (i+1) + ": " + t.q;
      card.appendChild(head);

      const body = document.createElement("div");
      body.className = "card-body";

      const label = document.createElement("div");
      label.textContent = "Rechne und trage das Ergebnis (nur Zahl) ein:";
      body.appendChild(label);

      const ta = document.createElement("textarea");
      body.appendChild(ta);

      const feedback = document.createElement("div");
      feedback.className = "feedback";
      body.appendChild(feedback);

      const solDiv = document.createElement("div");
      solDiv.className = "solution";
      solDiv.textContent = "Lösung: " + t.a;
      body.appendChild(solDiv);

      const btnShow = document.createElement("button");
      btnShow.type = "button";
      btnShow.textContent = "Lösung anzeigen";
      btnShow.onclick = () => {
        solDiv.style.display = (solDiv.style.display === "block" ? "none" : "block");
      };
      body.appendChild(btnShow);

      const numericExpected = getNumericAnswer(t.a.toString());

      const btnCheck = document.createElement("button");
      btnCheck.type = "button";
      btnCheck.textContent = "Überprüfen";
      btnCheck.onclick = () => {
        const valStr = ta.value.trim().replace(",", ".");
        const val = parseFloat(valStr);

        if (card.dataset.answered !== "true") {
          card.dataset.answered = "true";

          progress.answered++;
          if (!statsStore[SECTION_KEY]) {
            statsStore[SECTION_KEY] = {totalAnswered:0, totalCorrect:0};
          }
          statsStore[SECTION_KEY].totalAnswered++;
          saveStatsStore();

          meta.totalAnswered++;
          saveMeta();
        }

        if (isNaN(val)) {
          feedback.textContent = "Bitte eine Zahl eingeben.";
          feedback.className = "feedback bad";
          updateProgressDisplay();
          return;
        }

        if (Math.abs(val - numericExpected) < 0.001) {
          feedback.textContent = "Richtig!";
          feedback.className = "feedback ok";

          if (card.dataset.wasCorrect !== "true") {
            card.dataset.wasCorrect = "true";
            progress.correct++;
            statsStore[SECTION_KEY].totalCorrect++;
            saveStatsStore();
            onCorrectAnswer();
          }
        } else {
          feedback.textContent = "Nochmals nachrechnen.";
          feedback.className = "feedback bad";

          meta.currentStreak = 0;
          saveMeta();
          updateMetaUI();
        }

        updateProgressDisplay();
      };
      body.appendChild(btnCheck);

      card.appendChild(body);
      tasksContainer.appendChild(card);
    }
  }

  // Events
  document.getElementById("newTasksBtn").addEventListener("click", generateRound);

  document.getElementById("toggleAchievementsBtn").addEventListener("click", function () {
    const panel = document.getElementById("achievementsPanel");
    if (!panel) return;
    panel.style.display = (panel.style.display === "block" ? "none" : "block");
  });

  const difficultySelect = document.getElementById("difficultySelect");
  difficultySelect.addEventListener("change", function () {
    const val = this.value;
    const { level } = computeLevel();
    const mediumUnlocked = level >= 3;
    const hardUnlocked = level >= 6;

    if (val === "medium" && !mediumUnlocked) {
      alert("Mittel ist erst ab Level 3 freigeschaltet.");
      this.value = currentDifficulty;
      return;
    }
    if (val === "hard" && !hardUnlocked) {
      alert("Schwer ist erst ab Level 6 freigeschaltet.");
      this.value = currentDifficulty;
      return;
    }

    currentDifficulty = val;
    saveDifficulty();
    generateRound();
  });

  // Initial: UI updaten, Schwierigkeit anpassen, einmal Aufgaben erstellen
  updateMetaUI();
  generateRound();
</script>
</body>
</html>
